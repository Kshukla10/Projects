module one_bit_full_adder(A, B, Cin, S,
Cout);

input A, B, Cin;
output S, Cout;
  
assign S = A ^ B ^ Cin;
assign Cout = (A & B)|(B & Cin)|(Cin & A);
  
endmodule
//-----------------------------------------
  module one_bit_full_adder2(A, B, Cin, S, Cout);
    input A, B, Cin;
    output S, Cout;
    wire AxorB, AandB, AxorBandCin;

   // Structural logic using basic gates
    xor (AxorB, A, B);
    xor (S, AxorB, Cin);
    and (AandB, A, B);
    and (AxorBandCin, AxorB, Cin);
    or (Cout, AandB, AxorBandCin);

  endmodule

//-------------------------------------------
  module four_bit_RCA(A, B, Cin, S, Cout);
      input [3:0] A, B;
      input Cin;
      output [3:0] S;
      output Cout;
      wire C1, C2, C3;

      // Using four 1-bit full adders
      one_bit_full_adder FA0(A[0], B[0], Cin, S[0], C1);
      one_bit_full_adder FA1(A[1], B[1], C1, S[1], C2);
      one_bit_full_adder FA2(A[2], B[2], C2, S[2], C3);
      one_bit_full_adder FA3(A[3], B[3], C3, S[3], Cout);

  endmodule

//--------------------------------------------------

  module four_bit_RCA_RCS(A, B, sub, S, Cout);
     input [3:0] A, B;
      input sub; // 0 for addition, 1 for subtraction
      output [3:0] S;
      output Cout;
    
      wire [3:0] B_mux;
      wire C1, C2, C3;

      // MUX for selecting between B (addition) and ~B (subtraction)
      assign B_mux = B ^ {4{sub}}; 

      // Ripple-Carry Adder performing A + B_mux + sub (sub = Cin)
      one_bit_full_adder FA0(A[0], B_mux[0], sub, S[0], C1);
      one_bit_full_adder FA1(A[1], B_mux[1], C1, S[1], C2);
      one_bit_full_adder FA2(A[2], B_mux[2], C2, S[2], C3);
      one_bit_full_adder FA3(A[3], B_mux[3], C3, S[3], Cout);

  endmodule

